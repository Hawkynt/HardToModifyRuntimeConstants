// This file is auto-generated by ConstantObfuscator at compile time
// DO NOT EDIT MANUALLY - Changes will be overwritten

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HardToModifyRuntimeConstants;

public static class SecureConstants
{
    private readonly struct ConstantContainer()
    {
        public readonly ulong Pi = 0x8042DA2DD24B36E2UL;
        public readonly ulong E = 0x608E705B969BAD40UL;
        public readonly ulong Sqrt2 = 0x15C5A51B3149B670UL;
        public readonly ulong GoldenRatio = 0xBB83C58D5F672C69UL;
        public readonly uint MaxInt32 = 0x20960EC3U;
        public readonly uint Answer = 0x5A5E7394U;
        public readonly uint PiDecimal_Lo = 0x8DACA854U;
        public readonly uint PiDecimal_Mid = 0xDD8F504AU;
        public readonly uint PiDecimal_Hi = 0xF20BA60DU;
        public readonly uint PiDecimal_Flags = 0xB672DDCCU;
        public readonly uint EDecimal_Lo = 0xA98D67E7U;
        public readonly uint EDecimal_Mid = 0x22F7826AU;
        public readonly uint EDecimal_Hi = 0xF6B5D932U;
        public readonly uint EDecimal_Flags = 0x0650738FU;
        public readonly uint OnePercent_Lo = 0xEAB9078EU;
        public readonly uint OnePercent_Mid = 0x75FDE779U;
        public readonly uint OnePercent_Hi = 0x372D2AABU;
        public readonly uint OnePercent_Flags = 0xA29C6938U;
    }

    private static readonly long _storage;
    private static readonly long _storageKey = unchecked((long)0xDB3461DF26320BBBL);
    private static readonly long _sessionKey = unchecked((long)0x068BD4A95C16BC92L);
    private const long _pepper = unchecked((long)0xdeadbeefcaffee42);

    static SecureConstants()
    {
        ConstantContainer container = new();
        var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
        _storage = pointer ^ _storageKey ^ _sessionKey ^ _pepper;
    }
    public static unsafe double Pi =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->Pi,
            _storageKey, _sessionKey, "Pi"));

    public static unsafe double E =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->E,
            _storageKey, _sessionKey, "E"));

    public static unsafe double Sqrt2 =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->Sqrt2,
            _storageKey, _sessionKey, "Sqrt2"));

    public static unsafe double GoldenRatio =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->GoldenRatio,
            _storageKey, _sessionKey, "GoldenRatio"));

    public static unsafe int MaxInt32 =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->MaxInt32,
            _storageKey, _sessionKey, "MaxInt32");

    public static unsafe int Answer =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->Answer,
            _storageKey, _sessionKey, "Answer");

    public static unsafe decimal PiDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->PiDecimal_Lo, _storageKey, _sessionKey, "PiDecimal_0"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Mid, _storageKey, _sessionKey, "PiDecimal_1"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Hi, _storageKey, _sessionKey, "PiDecimal_2"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Flags, _storageKey, _sessionKey, "PiDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal EDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->EDecimal_Lo, _storageKey, _sessionKey, "EDecimal_0"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Mid, _storageKey, _sessionKey, "EDecimal_1"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Hi, _storageKey, _sessionKey, "EDecimal_2"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Flags, _storageKey, _sessionKey, "EDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal OnePercent
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->OnePercent_Lo, _storageKey, _sessionKey, "OnePercent_0"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Mid, _storageKey, _sessionKey, "OnePercent_1"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Hi, _storageKey, _sessionKey, "OnePercent_2"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Flags, _storageKey, _sessionKey, "OnePercent_3")
            ];
            return new decimal(bits);
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe ulong ReverseComplexObfuscation(ulong obfuscated, long key1, long key2, string identifier)
    {
        // Reverse the complex obfuscation applied at compile time
        uint identifierHash = (uint)identifier.GetHashCode();
        ulong keyMix = (ulong)(key1 ^ key2 ^ identifierHash);
        
        // Step 1: Reverse XOR
        ulong step1 = obfuscated ^ keyMix ^ 0xABCDEF0123456789UL;
        
        // Step 2: Reverse bit rotation (rotate right to undo left rotation)
        int rotation = (int)(identifierHash % 31) + 1; // 1-31
        ulong step2 = (step1 >> rotation) | (step1 << (64 - rotation));
        
        // Step 3: Reverse byte scrambling using unsafe pointer magic
        byte pattern = (byte)(identifierHash % 8);
        if (pattern == 0) return step2; // no scrambling
        
        byte* ptr = (byte*)&step2;
        ulong result;
        byte* resultPtr = (byte*)&result;
        
        switch (pattern)
        {
            case 1: // reverse: 3,1,7,0,4,6,2,5 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[3]; resultPtr[1] = ptr[1]; resultPtr[2] = ptr[6]; resultPtr[3] = ptr[0];
                resultPtr[4] = ptr[4]; resultPtr[5] = ptr[7]; resultPtr[6] = ptr[5]; resultPtr[7] = ptr[2];
                break;
            case 2: // reverse: 5,2,0,6,3,7,1,4 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[2]; resultPtr[1] = ptr[6]; resultPtr[2] = ptr[1]; resultPtr[3] = ptr[4];
                resultPtr[4] = ptr[7]; resultPtr[5] = ptr[0]; resultPtr[6] = ptr[3]; resultPtr[7] = ptr[5];
                break;
            case 3: // reverse: 6,3,1,5,7,0,4,2 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[5]; resultPtr[1] = ptr[2]; resultPtr[2] = ptr[7]; resultPtr[3] = ptr[1];
                resultPtr[4] = ptr[6]; resultPtr[5] = ptr[3]; resultPtr[6] = ptr[0]; resultPtr[7] = ptr[4];
                break;
            case 4: // reverse: 2,6,4,1,0,5,7,3 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[4]; resultPtr[1] = ptr[3]; resultPtr[2] = ptr[0]; resultPtr[3] = ptr[7];
                resultPtr[4] = ptr[2]; resultPtr[5] = ptr[5]; resultPtr[6] = ptr[1]; resultPtr[7] = ptr[6];
                break;
            case 5: // reverse: 1,7,5,3,6,2,0,4 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[6]; resultPtr[1] = ptr[0]; resultPtr[2] = ptr[5]; resultPtr[3] = ptr[3];
                resultPtr[4] = ptr[7]; resultPtr[5] = ptr[2]; resultPtr[6] = ptr[4]; resultPtr[7] = ptr[1];
                break;
            case 6: // reverse: 4,0,6,2,1,3,5,7 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[1]; resultPtr[1] = ptr[4]; resultPtr[2] = ptr[6]; resultPtr[3] = ptr[5];
                resultPtr[4] = ptr[0]; resultPtr[5] = ptr[2]; resultPtr[6] = ptr[7]; resultPtr[7] = ptr[3];
                break;
            case 7: // reverse: 7,5,2,6,1,4,3,0 -> 0,1,2,3,4,5,6,7
                resultPtr[0] = ptr[7]; resultPtr[1] = ptr[5]; resultPtr[2] = ptr[2]; resultPtr[3] = ptr[6];
                resultPtr[4] = ptr[1]; resultPtr[5] = ptr[4]; resultPtr[6] = ptr[3]; resultPtr[7] = ptr[0];
                break;
            default:
                return step2;
        }
        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe uint ReverseComplexObfuscation32(uint obfuscated, long key1, long key2, string identifier)
    {
        uint identifierHash = (uint)identifier.GetHashCode();
        uint keyMix = (uint)((key1 ^ key2) ^ identifierHash);
        
        uint step1 = obfuscated ^ keyMix ^ 0x12345678U;
        int rotation = (int)(identifierHash % 15) + 1; // 1-15
        uint step2 = (step1 >> rotation) | (step1 << (32 - rotation));
        
        byte pattern = (byte)(identifierHash % 4);
        if (pattern == 0) return step2;
        
        byte* ptr = (byte*)&step2;
        uint result;
        byte* resultPtr = (byte*)&result;
        
        switch (pattern)
        {
            case 1: // reverse: 3,1,0,2 -> 0,1,2,3
                resultPtr[0] = ptr[2]; resultPtr[1] = ptr[1]; resultPtr[2] = ptr[3]; resultPtr[3] = ptr[0];
                break;
            case 2: // reverse: 2,0,3,1 -> 0,1,2,3
                resultPtr[0] = ptr[1]; resultPtr[1] = ptr[3]; resultPtr[2] = ptr[0]; resultPtr[3] = ptr[2];
                break;
            case 3: // reverse: 1,2,3,0 -> 0,1,2,3
                resultPtr[0] = ptr[3]; resultPtr[1] = ptr[0]; resultPtr[2] = ptr[1]; resultPtr[3] = ptr[2];
                break;
            default:
                return step2;
        }
        return result;
    }
}