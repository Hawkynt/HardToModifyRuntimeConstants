// This file is auto-generated by ConstantObfuscator at compile time
// DO NOT EDIT MANUALLY - Changes will be overwritten

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HardToModifyRuntimeConstants;

public static class SecureConstants
{
    private readonly struct ConstantContainer()
    {
        public readonly ulong Pi = 0x11F25858A4C9F4BCUL;
        public readonly ulong E = 0x83BCDA8B181B6FB0UL;
        public readonly ulong Sqrt2 = 0x93881EEE3E6F1809UL;
        public readonly ulong GoldenRatio = 0xBD518B7994688EE3UL;
        public readonly uint MaxInt32 = 0x0E301162U;
        public readonly uint Answer = 0x1B8E2E73U;
        public readonly uint PiDecimal_Lo = 0xAF51FED8U;
        public readonly uint PiDecimal_Mid = 0x32FA253CU;
        public readonly uint PiDecimal_Hi = 0x3F211D35U;
        public readonly uint PiDecimal_Flags = 0xEF659C38U;
        public readonly uint EDecimal_Lo = 0x5474C029U;
        public readonly uint EDecimal_Mid = 0x3FD34895U;
        public readonly uint EDecimal_Hi = 0x0A5BC5D5U;
        public readonly uint EDecimal_Flags = 0x465EE9C0U;
        public readonly uint OnePercent_Lo = 0xE5F373DDU;
        public readonly uint OnePercent_Mid = 0xC9087BBEU;
        public readonly uint OnePercent_Hi = 0x9A26DD72U;
        public readonly uint OnePercent_Flags = 0xBD578C22U;
    }

    private static readonly long _storage;
    private static readonly long _storageKey = Random.Shared.NextInt64();
    private const long _pepper = unchecked((long)0x47B3974FBE643000L);

    static SecureConstants()
    {
        ConstantContainer container = new();
        var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
        _storage = pointer ^ _storageKey ^ _pepper;
    }
    public static unsafe double Pi =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Pi,
            _pepper, "Pi"));

    public static unsafe double E =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->E,
            _pepper, "E"));

    public static unsafe double Sqrt2 =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Sqrt2,
            _pepper, "Sqrt2"));

    public static unsafe double GoldenRatio =>
        BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->GoldenRatio,
            _pepper, "GoldenRatio"));

    public static unsafe int MaxInt32 =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->MaxInt32,
            _pepper, "MaxInt32");

    public static unsafe int Answer =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Answer,
            _pepper, "Answer");

    public static unsafe decimal PiDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->PiDecimal_Lo, _pepper, "PiDecimal_0"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Mid, _pepper, "PiDecimal_1"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Hi, _pepper, "PiDecimal_2"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Flags, _pepper, "PiDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal EDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->EDecimal_Lo, _pepper, "EDecimal_0"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Mid, _pepper, "EDecimal_1"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Hi, _pepper, "EDecimal_2"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Flags, _pepper, "EDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal OnePercent
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->OnePercent_Lo, _pepper, "OnePercent_0"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Mid, _pepper, "OnePercent_1"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Hi, _pepper, "OnePercent_2"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Flags, _pepper, "OnePercent_3")
            ];
            return new decimal(bits);
        }
    }internal static unsafe ulong ReverseComplexObfuscation(ulong scrambled, long key, string identifier)
{
    uint identifierHash = (uint)identifier.GetHashCode();
    ulong keyMix = (ulong)(key ^ identifierHash);

    // Step 1: Byte scrambling based on identifier hash using unsafe pointers
    byte pattern = (byte)(identifierHash % 8);
    ulong value;

    byte* srcPtr = (byte*)&value;
    byte* destPtr = (byte*)&scrambled;

    switch (pattern)
    {
        case 0:
            (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 1:
            (srcPtr[3], srcPtr[1], srcPtr[7], srcPtr[0], srcPtr[4], srcPtr[6], srcPtr[2], srcPtr[5])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 2:
            (srcPtr[5], srcPtr[2], srcPtr[0], srcPtr[6], srcPtr[3], srcPtr[7], srcPtr[1], srcPtr[4])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 3:
            (srcPtr[6], srcPtr[3], srcPtr[1], srcPtr[5], srcPtr[7], srcPtr[0], srcPtr[4], srcPtr[2])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 4:
            (srcPtr[2], srcPtr[6], srcPtr[4], srcPtr[1], srcPtr[0], srcPtr[5], srcPtr[7], srcPtr[3])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 5:
            (srcPtr[1], srcPtr[7], srcPtr[5], srcPtr[3], srcPtr[6], srcPtr[2], srcPtr[0], srcPtr[4])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 6:
            (srcPtr[4], srcPtr[0], srcPtr[6], srcPtr[2], srcPtr[1], srcPtr[3], srcPtr[5], srcPtr[7])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
        case 7:
            (srcPtr[7], srcPtr[4], srcPtr[2], srcPtr[6], srcPtr[5], srcPtr[1], srcPtr[3], srcPtr[0])
          = (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7]);
            break;
    }

    // Step 2: Bit rotation based on identifier
    int rotation = (int)(identifierHash % 31) + 1; // 1-31 bit rotation
    ulong rotated = (value >> rotation) | (value << (64 - rotation));

    // Step 3: XOR with keys and magic constant
    return rotated ^ keyMix ^ 0xABCDEF0123456789UL;
}

internal static unsafe uint ReverseComplexObfuscation32(uint value, long key, string identifier)
{
    uint identifierHash = (uint)identifier.GetHashCode();
    uint keyMix = (uint)(key ^ identifierHash);

    // Byte scrambling for 32-bit values using unsafe pointers
    byte pattern = (byte)(identifierHash % 4);
    uint scrambled;

    byte* srcPtr = (byte*)&value;
    byte* destPtr = (byte*)&scrambled;
    (destPtr[0], destPtr[1], destPtr[2], destPtr[3]) = pattern switch
    {
        1 => (srcPtr[3], srcPtr[1], srcPtr[0], srcPtr[2]),
        2 => (srcPtr[2], srcPtr[0], srcPtr[3], srcPtr[1]),
        3 => (srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[0]),
        _ => (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3])
    };

    // Bit rotation
    int rotation = (int)(identifierHash % 15) + 1; // 1-15 bit rotation
    uint rotated = (scrambled << rotation) | (scrambled >> (32 - rotation));

    return rotated ^ keyMix ^ 0x12345678U;
}}