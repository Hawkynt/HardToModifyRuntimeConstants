// This file is auto-generated by ConstantObfuscator at compile time
// DO NOT EDIT MANUALLY - Changes will be overwritten

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace HardToModifyRuntimeConstants {

public static partial class SecureConstants
{
    private readonly struct ConstantContainer()
    {
        public readonly ulong Pi = 0x1A68AF604E73BF8AUL;
        public readonly ulong E = 0xB6A0079BE0531AFBUL;
        public readonly ulong Sqrt2 = 0x1818F642BADC0FA2UL;
        public readonly ulong GoldenRatio = 0x380FC9C9C23B1F8CUL;
        public readonly uint MaxInt32 = 0x886EC153U;
        public readonly uint Answer = 0xB56CA4E1U;
        public readonly uint PiDecimal_Lo = 0x2818B605U;
        public readonly uint PiDecimal_Mid = 0x190DF3D6U;
        public readonly uint PiDecimal_Hi = 0x0C59EFAEU;
        public readonly uint PiDecimal_Flags = 0x4A8D401EU;
        public readonly uint EDecimal_Lo = 0xF36C1908U;
        public readonly uint EDecimal_Mid = 0x457AFDE5U;
        public readonly uint EDecimal_Hi = 0x2B27BC2BU;
        public readonly uint EDecimal_Flags = 0xC80D461DU;
        public readonly uint OnePercent_Lo = 0xC96203D4U;
        public readonly uint OnePercent_Mid = 0xC9620344U;
        public readonly uint OnePercent_Hi = 0xC96202C4U;
        public readonly uint OnePercent_Flags = 0xC9621244U;
    }

    private static readonly long _storage;
    private static readonly long _storageKey = Random.Shared.NextInt64();
    private const long _pepper = unchecked((long)0x4C0F6277EB16E813L);

    static SecureConstants()
    {
        ConstantContainer container = new();
        var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
        _storage = pointer ^ _storageKey ^ _pepper;
    }
    public static unsafe double Pi =>
        Unsafe.BitCast<ulong, double>(ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Pi,
            _pepper, "Pi"));

    public static unsafe double E =>
        Unsafe.BitCast<ulong, double>(ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->E,
            _pepper, "E"));

    public static unsafe double Sqrt2 =>
        Unsafe.BitCast<ulong, double>(ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Sqrt2,
            _pepper, "Sqrt2"));

    public static unsafe double GoldenRatio =>
        Unsafe.BitCast<ulong, double>(ReverseComplexObfuscation(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->GoldenRatio,
            _pepper, "GoldenRatio"));

    public static unsafe int MaxInt32 =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->MaxInt32,
            _pepper, "MaxInt32");

    public static unsafe int Answer =>
        (int)ReverseComplexObfuscation32(
            ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->Answer,
            _pepper, "Answer");

    public static unsafe decimal PiDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->PiDecimal_Lo, _pepper, "PiDecimal_0"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Mid, _pepper, "PiDecimal_1"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Hi, _pepper, "PiDecimal_2"),
                (int)ReverseComplexObfuscation32(container->PiDecimal_Flags, _pepper, "PiDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal EDecimal
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->EDecimal_Lo, _pepper, "EDecimal_0"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Mid, _pepper, "EDecimal_1"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Hi, _pepper, "EDecimal_2"),
                (int)ReverseComplexObfuscation32(container->EDecimal_Flags, _pepper, "EDecimal_3")
            ];
            return new decimal(bits);
        }
    }

    public static unsafe decimal OnePercent
    {
        get
        {
            var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
            int[] bits = [
                (int)ReverseComplexObfuscation32(container->OnePercent_Lo, _pepper, "OnePercent_0"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Mid, _pepper, "OnePercent_1"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Hi, _pepper, "OnePercent_2"),
                (int)ReverseComplexObfuscation32(container->OnePercent_Flags, _pepper, "OnePercent_3")
            ];
            return new decimal(bits);
        }
    }

}
}
// MUST NOT HAVE USINGS!

namespace HardToModifyRuntimeConstants
{

    partial class SecureConstants
    {
        private static uint Hash(string name) => System.Text.Encoding.Unicode.GetBytes(name).Aggregate(0U, (c, n) => ((c << 7) | (c >> 25)) ^ n);

        internal static unsafe ulong ReverseComplexObfuscation(ulong obfuscated, long key, string identifier)
        {
            var identifierHash = Hash(identifier);
            ulong keyMix = (ulong)(key ^ identifierHash);

            // Step 3 (reverse): XOR with keys and magic constant
            ulong rotated = obfuscated ^ keyMix ^ 0xABCDEF0123456789UL;

            // Step 2 (reverse): Bit rotation - RIGHT rotation to undo LEFT rotation
            int rotation = (int)(identifierHash % 31) + 1; // 1-31 bit rotation
            ulong scrambled = (rotated >> rotation) | (rotated << (64 - rotation));

            // Step 1 (reverse): Byte unscrambling - inverse of forward scrambling
            byte pattern = (byte)(identifierHash % 8);
            ulong value;
            
            byte* srcPtr = (byte*)&scrambled;
            byte* destPtr = (byte*)&value;

            switch (pattern)
            {
                case 0:
                    (destPtr[0], destPtr[1], destPtr[2], destPtr[3], destPtr[4], destPtr[5], destPtr[6], destPtr[7])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 1:
                    (destPtr[3], destPtr[1], destPtr[7], destPtr[0], destPtr[4], destPtr[6], destPtr[2], destPtr[5])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 2:
                    (destPtr[5], destPtr[2], destPtr[0], destPtr[6], destPtr[3], destPtr[7], destPtr[1], destPtr[4])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 3:
                    (destPtr[6], destPtr[3], destPtr[1], destPtr[5], destPtr[7], destPtr[0], destPtr[4], destPtr[2])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 4:
                    (destPtr[2], destPtr[6], destPtr[4], destPtr[1], destPtr[0], destPtr[5], destPtr[7], destPtr[3])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 5:
                    (destPtr[1], destPtr[7], destPtr[5], destPtr[3], destPtr[6], destPtr[2], destPtr[0], destPtr[4])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 6:
                    (destPtr[4], destPtr[0], destPtr[6], destPtr[2], destPtr[1], destPtr[3], destPtr[5], destPtr[7])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
                case 7:
                    (destPtr[7], destPtr[4], destPtr[2], destPtr[6], destPtr[5], destPtr[1], destPtr[3], destPtr[0])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3], srcPtr[4], srcPtr[5], srcPtr[6], srcPtr[7]);
                    break;
            }
            
            return value;
        }

        internal static unsafe uint ReverseComplexObfuscation32(uint obfuscated, long key, string identifier)
        {
            var identifierHash = Hash(identifier);
            uint keyMix = (uint)(key ^ identifierHash);

            // Step 3 (reverse): XOR
            uint rotated = obfuscated ^ keyMix ^ 0x12345678U;

            // Step 2 (reverse): Bit rotation - RIGHT rotation to undo LEFT
            int rotation = (int)(identifierHash % 15) + 1; // 1-15 bit rotation
            uint scrambled = (rotated >> rotation) | (rotated << (32 - rotation));

            // Step 1 (reverse): Byte unscrambling
            byte pattern = (byte)(identifierHash % 4);
            uint value;

            byte* srcPtr = (byte*)&scrambled;
            byte* destPtr = (byte*)&value;
            switch (pattern)
            {
                case 0:
                    (destPtr[0], destPtr[1], destPtr[2], destPtr[3])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3]);
                    break;
                case 1:
                    (destPtr[3], destPtr[1], destPtr[0], destPtr[2])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3]);
                    break;
                case 2:
                    (destPtr[2], destPtr[0], destPtr[3], destPtr[1])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3]);
                    break;
                case 3:
                    (destPtr[1], destPtr[2], destPtr[3], destPtr[0])
                  = (srcPtr[0], srcPtr[1], srcPtr[2], srcPtr[3]);
                    break;
            }

            return value;
        }

    }
}