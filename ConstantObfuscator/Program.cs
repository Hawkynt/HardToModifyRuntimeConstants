using System.Globalization;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

namespace ConstantObfuscator;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.WriteLine("Usage: ConstantObfuscator <output-directory>");
            Environment.Exit(1);
        }

        string outputDir = args[0];
        Directory.CreateDirectory(outputDir);

        Console.WriteLine("üîê Generating compile-time obfuscated constants...");

        // Define constants to obfuscate
        var doubleConstants = new Dictionary<string, double>
        {
            ["Pi"] = Math.PI,
            ["E"] = Math.E,
            ["Sqrt2"] = Math.Sqrt(2),
            ["GoldenRatio"] = (1 + Math.Sqrt(5)) / 2
        };

        var intConstants = new Dictionary<string, int>
        {
            ["MaxInt32"] = int.MaxValue,
            ["Answer"] = 42
        };

        var decimalConstants = new Dictionary<string, decimal>
        {
            ["PiDecimal"] = 3.1415926535897932384626433833m,
            ["EDecimal"] = 2.7182818284590452353602874714m,
            ["OnePercent"] = 0.01m
        };

        // Generate Level 3: Compile-time obfuscated constants
        FileInfo level3File = new(Path.Combine(outputDir, "Constants.Level3.generated.cs"));
        if(level3File.Exists) level3File.Delete();
        GenerateSecureConstants(level3File, doubleConstants, intConstants, decimalConstants);

        // Generate Level 4: Asymmetric encryption constants  
        FileInfo level4File = new(Path.Combine(outputDir, "Constants.Level4.generated.cs"));
        if (level4File.Exists) level4File.Delete();
        GenerateAsymmetricConstants(level4File, doubleConstants, intConstants, decimalConstants);

        Console.WriteLine("‚úÖ All obfuscated constants generated successfully!");
    }

    static void GenerateSecureConstants(FileInfo outputFile, 
        Dictionary<string, double> doubleConstants,
        Dictionary<string, int> intConstants, 
        Dictionary<string, decimal> decimalConstants)
    {

        // Generate cryptographically random keys for this build
        using var rng = RandomNumberGenerator.Create();
        var keyBytes = new byte[8];
        rng.GetBytes(keyBytes);
        long randomKey = BitConverter.ToInt64(keyBytes);

        // Generate obfuscated values
        var doubleObfuscated = doubleConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => Level3.ApplyComplexObfuscation(Unsafe.BitCast<double, ulong>(kvp.Value), randomKey, kvp.Key)
        );

        var intObfuscated = intConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => Level3.ApplyComplexObfuscation32((uint)kvp.Value, randomKey, kvp.Key)
        );

        var decimalObfuscated = decimalConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => {
                var bits = decimal.GetBits(kvp.Value);
                return new uint[] {
                    Level3.ApplyComplexObfuscation32((uint)bits[0], randomKey, $"{kvp.Key}_0"),
                    Level3.ApplyComplexObfuscation32((uint)bits[1], randomKey, $"{kvp.Key}_1"),
                    Level3.ApplyComplexObfuscation32((uint)bits[2], randomKey, $"{kvp.Key}_2"),
                    Level3.ApplyComplexObfuscation32((uint)bits[3], randomKey, $"{kvp.Key}_3")
                };
            }
        );

        string content = $$"""
            // This file is auto-generated by ConstantObfuscator at compile time
            // DO NOT EDIT MANUALLY - Changes will be overwritten

            using System.Runtime.CompilerServices;
            using System.Runtime.InteropServices;

            namespace HardToModifyRuntimeConstants {

            public static partial class SecureConstants
            {
                private readonly struct ConstantContainer()
                {
            {{string.Join("\n", doubleObfuscated.Select(kvp => $"        public readonly ulong {kvp.Key} = 0x{kvp.Value:X16}UL;"))}}
            {{string.Join("\n", intObfuscated.Select(kvp => $"        public readonly uint {kvp.Key} = 0x{kvp.Value:X8}U;"))}}
            {{string.Join("\n", decimalObfuscated.SelectMany(kvp => new[] {
                $"        public readonly uint {kvp.Key}_Lo = 0x{kvp.Value[0]:X8}U;",
                $"        public readonly uint {kvp.Key}_Mid = 0x{kvp.Value[1]:X8}U;",
                $"        public readonly uint {kvp.Key}_Hi = 0x{kvp.Value[2]:X8}U;",
                $"        public readonly uint {kvp.Key}_Flags = 0x{kvp.Value[3]:X8}U;"
            }))}}
                }

                private static readonly long _storage;
                private static readonly long _storageKey = Random.Shared.NextInt64();
                private const long _pepper = unchecked((long)0x{{randomKey:X16}}L);

                static SecureConstants()
                {
                    ConstantContainer container = new();
                    var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
                    _storage = pointer ^ _storageKey ^ _pepper;
                }
            """;

        // Generate property accessors
        string doubleAccessors = string.Join("\n\n", doubleConstants.Keys.Select(key => $$"""
                public static unsafe double {{key}} =>
                    Unsafe.BitCast<ulong, double>(ReverseComplexObfuscation(
                        ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->{{key}},
                        _pepper, "{{key}}"));
            """));

        string intAccessors = string.Join("\n\n", intConstants.Keys.Select(key => $$"""
                public static unsafe int {{key}} =>
                    (int)ReverseComplexObfuscation32(
                        ((ConstantContainer*)(_storage ^ _storageKey ^ _pepper))->{{key}},
                        _pepper, "{{key}}");
            """));

        string decimalAccessors = string.Join("\n\n", decimalConstants.Keys.Select(key => $$"""
                public static unsafe decimal {{key}}
                {
                    get
                    {
                        var container = (ConstantContainer*)(_storage ^ _storageKey ^ _pepper);
                        int[] bits = [
                            (int)ReverseComplexObfuscation32(container->{{key}}_Lo, _pepper, "{{key}}_0"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Mid, _pepper, "{{key}}_1"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Hi, _pepper, "{{key}}_2"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Flags, _pepper, "{{key}}_3")
                        ];
                        return new decimal(bits);
                    }
                }
            """));

        content += $$"""

            {{doubleAccessors}}

            {{intAccessors}}

            {{decimalAccessors}}

            }
            }

            """;

        // Generate obfuscation/deobfuscation methods
        string backwardPath = Path.Combine(AppContext.BaseDirectory, "Level3.Backward.cs");
        if (!File.Exists(backwardPath))
        {
            // Try alternative path for when running from project directory
            backwardPath = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)!, "..", "..", "..", "Level3.Backward.cs");
        }
        content += File.ReadAllText(backwardPath);
        
        
        // Write the generated file
        File.WriteAllText(outputFile.FullName, content);
        Console.WriteLine($"Generated: {outputFile.Name}");
    }

    static void GenerateAsymmetricConstants(FileInfo outputFile, 
        Dictionary<string, double> doubleConstants,
        Dictionary<string, int> intConstants, 
        Dictionary<string, decimal> decimalConstants)
    {
        Console.WriteLine("üîê Generating Level 4: One-way decryption constants...");

        // Generate RSA key pair (private key stored for runtime decryption)
        using var rsa = RSA.Create(2048);
        var publicKey = rsa.ExportRSAPublicKey();
        var privateKey = rsa.ExportRSAPrivateKey(); // Stored for runtime decryption

        // Encrypt all constants with public key (can only be decrypted with private key)
        var encryptedConstants = new Dictionary<string, byte[]>();
        
        foreach (var kvp in doubleConstants)
        {
            byte[] valueBytes = BitConverter.GetBytes(kvp.Value);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }
        
        foreach (var kvp in intConstants)
        {
            byte[] valueBytes = BitConverter.GetBytes(kvp.Value);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }
        
        foreach (var kvp in decimalConstants)
        {
            int[] decimalBits = decimal.GetBits(kvp.Value);
            byte[] valueBytes = new byte[16];
            Buffer.BlockCopy(decimalBits, 0, valueBytes, 0, 16);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }

        // Helper method to format byte arrays as hex
        static string FormatByteArray(byte[] bytes)
        {
            var result = new StringBuilder();
            for (int i = 0; i < bytes.Length; i++)
            {
                result.Append($"0x{bytes[i]:X2}");
                
                if (i < bytes.Length - 1)
                {
                    result.Append(", ");
                    if ((i + 1) % 16 == 0)
                    {
                        result.Append("\n            ");
                    }
                }
            }
            return result.ToString();
        }

        string content = $$"""
            // Level 4: One-Way Decryption Constants
            // Private key stored for runtime decryption (one-way only)
            // This file is auto-generated by ConstantObfuscator at compile time
            // DO NOT EDIT MANUALLY - Changes will be overwritten

            using System.Runtime.CompilerServices;
            using System.Runtime.InteropServices;
            using System.Security.Cryptography;

            namespace HardToModifyRuntimeConstants;

            public static class CryptoConstants
            {
                private readonly struct EncryptedContainer()
                {
            {{string.Join("\n", encryptedConstants.Select(kvp => $$"""
                        public static readonly byte[] {{kvp.Key}} = new byte[]
                        {
                            {{FormatByteArray(kvp.Value)}}
                        };
            """))}}
                }

                // Only private key stored for one-way decryption
                // Public key is NOT stored to prevent re-encryption attacks
                private static readonly byte[] _privateKeyBytes = new byte[]
                {
                    {{FormatByteArray(privateKey)}}
                };

                private static readonly long _storage;
                private static readonly RSA? _rsa;
                private const long _pepper = unchecked((long)0xC437910C05744775);

                static CryptoConstants()
                {
                    EncryptedContainer container = new();
                    var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
                    _storage = pointer ^ _pepper;
                    
                    // Create RSA instance with private key for decryption
                    try
                    {
                        _rsa = RSA.Create();
                        _rsa.ImportRSAPrivateKey(_privateKeyBytes, out _);
                    }
                    catch
                    {
                        _rsa = null; // Graceful degradation
                    }
                }

            {{string.Join("\n\n", doubleConstants.Keys.Select(key => $$"""
                    public static double {{key}}
                    {
                        get
                        {
                            if (_rsa == null)
                                throw new CryptographicException("RSA instance not available for decryption.");
                            
                            try
                            {
                                byte[] decryptedBytes = _rsa.Decrypt(EncryptedContainer.{{key}}, RSAEncryptionPadding.Pkcs1);
                                return BitConverter.ToDouble(decryptedBytes, 0);
                            }
                            catch (Exception ex)
                            {
                                throw new CryptographicException($"Failed to decrypt constant {{key}}: {ex.Message}", ex);
                            }
                        }
                    }
            """))}}

            {{string.Join("\n\n", intConstants.Keys.Select(key => $$"""
                    public static int {{key}}
                    {
                        get
                        {
                            if (_rsa == null)
                                throw new CryptographicException("RSA instance not available for decryption.");
                                
                            try
                            {
                                byte[] decryptedBytes = _rsa.Decrypt(EncryptedContainer.{{key}}, RSAEncryptionPadding.Pkcs1);
                                return BitConverter.ToInt32(decryptedBytes, 0);
                            }
                            catch (Exception ex)
                            {
                                throw new CryptographicException($"Failed to decrypt constant {{key}}: {ex.Message}", ex);
                            }
                        }
                    }
            """))}}

            {{string.Join("\n\n", decimalConstants.Keys.Select(key => $$"""
                    public static decimal {{key}}
                    {
                        get
                        {
                            if (_rsa == null)
                                throw new CryptographicException("RSA instance not available for decryption.");
                                
                            try
                            {
                                byte[] decryptedBytes = _rsa.Decrypt(EncryptedContainer.{{key}}, RSAEncryptionPadding.Pkcs1);
                                int[] bits = new int[4];
                                Buffer.BlockCopy(decryptedBytes, 0, bits, 0, 16);
                                return new decimal(bits);
                            }
                            catch (Exception ex)
                            {
                                throw new CryptographicException($"Failed to decrypt constant {{key}}: {ex.Message}", ex);
                            }
                        }
                    }
            """))}}

                /// <summary>
                /// One-way decryption: Constants can be decrypted at runtime but the process is irreversible.
                /// Values are encrypted at compile-time and can only be accessed through decryption.
                /// </summary>
                public static string GetSecurityInfo()
                {
                    return $"Level 4 Security: One-way decryption with RSA-2048. " +
                           $"Constants encrypted at compile-time, decryptable at runtime. " +
                           $"Public key NOT stored (prevents re-encryption attacks). " +
                           $"Private key size: {_privateKeyBytes.Length} bytes. " +
                           $"Decryption is one-way only - values cannot be re-encrypted.";
                }
            }
            """;

        // Write the generated file
        File.WriteAllText(outputFile.FullName, content);
        
        Console.WriteLine($"Generated: {outputFile.Name}");
        Console.WriteLine($"üîë PRIVATE KEY ONLY - enables one-way runtime decryption!");
        Console.WriteLine($"üö´ Public key NOT stored - prevents re-encryption attacks");
        Console.WriteLine($"üîê Private key stored ({privateKey.Length} bytes) - allows decryption only");
        Console.WriteLine("üí° Constants can be decrypted at runtime but cannot be re-encrypted");
    }
}
