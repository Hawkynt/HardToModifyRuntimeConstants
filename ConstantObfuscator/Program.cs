using System.Globalization;
using System.Security.Cryptography;
using System.Text;

namespace ConstantObfuscator;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.WriteLine("Usage: ConstantObfuscator <output-directory>");
            Environment.Exit(1);
        }

        string outputDir = args[0];
        Directory.CreateDirectory(outputDir);

        Console.WriteLine("üîê Generating compile-time obfuscated constants...");

        // Generate cryptographically random keys for this build
        using var rng = RandomNumberGenerator.Create();
        var keyBytes = new byte[8];
        rng.GetBytes(keyBytes);
        long randomKey = BitConverter.ToInt64(keyBytes);

        rng.GetBytes(keyBytes);
        long sessionKey = BitConverter.ToInt64(keyBytes);

        // Define constants to obfuscate
        var constants = new Dictionary<string, double>
        {
            ["Pi"] = Math.PI,
            ["E"] = Math.E,
            ["Sqrt2"] = Math.Sqrt(2),
            ["GoldenRatio"] = (1 + Math.Sqrt(5)) / 2
        };

        var intConstants = new Dictionary<string, int>
        {
            ["MaxInt32"] = int.MaxValue,
            ["Answer"] = 42
        };

        var decimalConstants = new Dictionary<string, decimal>
        {
            ["PiDecimal"] = 3.1415926535897932384626433833m,
            ["EDecimal"] = 2.7182818284590452353602874714m,
            ["OnePercent"] = 0.01m
        };

        // Generate Level 3: Compile-time obfuscated constants
        GenerateSecureConstants(outputDir, constants, intConstants, decimalConstants, randomKey, sessionKey);

        // Generate Level 4: Asymmetric encryption constants  
        GenerateAsymmetricConstants(outputDir, constants, intConstants, decimalConstants);

        Console.WriteLine("‚úÖ All obfuscated constants generated successfully!");
    }

    static void GenerateSecureConstants(string outputDir, 
        Dictionary<string, double> doubleConstants,
        Dictionary<string, int> intConstants, 
        Dictionary<string, decimal> decimalConstants,
        long randomKey, long sessionKey)
    {
        // Generate obfuscated values
        var doubleObfuscated = doubleConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => ApplyComplexObfuscation((ulong)BitConverter.DoubleToInt64Bits(kvp.Value), randomKey, sessionKey, kvp.Key)
        );

        var intObfuscated = intConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => ApplyComplexObfuscation32((uint)kvp.Value, randomKey, sessionKey, kvp.Key)
        );

        var decimalObfuscated = decimalConstants.ToDictionary(
            kvp => kvp.Key,
            kvp => {
                var bits = decimal.GetBits(kvp.Value);
                return new uint[] {
                    ApplyComplexObfuscation32((uint)bits[0], randomKey, sessionKey, $"{kvp.Key}_0"),
                    ApplyComplexObfuscation32((uint)bits[1], randomKey, sessionKey, $"{kvp.Key}_1"),
                    ApplyComplexObfuscation32((uint)bits[2], randomKey, sessionKey, $"{kvp.Key}_2"),
                    ApplyComplexObfuscation32((uint)bits[3], randomKey, sessionKey, $"{kvp.Key}_3")
                };
            }
        );

        string content = $$"""
            // This file is auto-generated by ConstantObfuscator at compile time
            // DO NOT EDIT MANUALLY - Changes will be overwritten

            using System.Runtime.CompilerServices;
            using System.Runtime.InteropServices;

            namespace HardToModifyRuntimeConstants;

            public static class SecureConstants
            {
                private readonly struct ConstantContainer()
                {
            {{string.Join("\n", doubleObfuscated.Select(kvp => $"        public readonly ulong {kvp.Key} = 0x{kvp.Value:X16}UL;"))}}
            {{string.Join("\n", intObfuscated.Select(kvp => $"        public readonly uint {kvp.Key} = 0x{kvp.Value:X8}U;"))}}
            {{string.Join("\n", decimalObfuscated.SelectMany(kvp => new[] {
                $"        public readonly uint {kvp.Key}_Lo = 0x{kvp.Value[0]:X8}U;",
                $"        public readonly uint {kvp.Key}_Mid = 0x{kvp.Value[1]:X8}U;",
                $"        public readonly uint {kvp.Key}_Hi = 0x{kvp.Value[2]:X8}U;",
                $"        public readonly uint {kvp.Key}_Flags = 0x{kvp.Value[3]:X8}U;"
            }))}}
                }

                private static readonly long _storage;
                private static readonly long _storageKey = unchecked((long)0x{{randomKey:X16}}L);
                private static readonly long _sessionKey = unchecked((long)0x{{sessionKey:X16}}L);
                private const long _pepper = unchecked((long)0xdeadbeefcaffee42);

                static SecureConstants()
                {
                    ConstantContainer container = new();
                    var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
                    _storage = pointer ^ _storageKey ^ _sessionKey ^ _pepper;
                }
            """;

        // Generate property accessors
        string doubleAccessors = string.Join("\n\n", doubleConstants.Keys.Select(key => $$"""
                public static unsafe double {{key}} =>
                    BitConverter.Int64BitsToDouble((long)ReverseComplexObfuscation(
                        ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->{{key}},
                        _storageKey, _sessionKey, "{{key}}"));
            """));

        string intAccessors = string.Join("\n\n", intConstants.Keys.Select(key => $$"""
                public static unsafe int {{key}} =>
                    (int)ReverseComplexObfuscation32(
                        ((ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper))->{{key}},
                        _storageKey, _sessionKey, "{{key}}");
            """));

        string decimalAccessors = string.Join("\n\n", decimalConstants.Keys.Select(key => $$"""
                public static unsafe decimal {{key}}
                {
                    get
                    {
                        var container = (ConstantContainer*)(_storage ^ _storageKey ^ _sessionKey ^ _pepper);
                        int[] bits = [
                            (int)ReverseComplexObfuscation32(container->{{key}}_Lo, _storageKey, _sessionKey, "{{key}}_0"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Mid, _storageKey, _sessionKey, "{{key}}_1"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Hi, _storageKey, _sessionKey, "{{key}}_2"),
                            (int)ReverseComplexObfuscation32(container->{{key}}_Flags, _storageKey, _sessionKey, "{{key}}_3")
                        ];
                        return new decimal(bits);
                    }
                }
            """));

        content += $"""

            {doubleAccessors}

            {intAccessors}

            {decimalAccessors}
            """;

        // Generate obfuscation/deobfuscation methods
        content += """

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private static unsafe ulong ReverseComplexObfuscation(ulong obfuscated, long key1, long key2, string identifier)
                {
                    // Reverse the complex obfuscation applied at compile time
                    uint identifierHash = (uint)identifier.GetHashCode();
                    ulong keyMix = (ulong)(key1 ^ key2 ^ identifierHash);
                    
                    // Step 1: Reverse XOR
                    ulong step1 = obfuscated ^ keyMix ^ 0xABCDEF0123456789UL;
                    
                    // Step 2: Reverse bit rotation (rotate right to undo left rotation)
                    int rotation = (int)(identifierHash % 31) + 1; // 1-31
                    ulong step2 = (step1 >> rotation) | (step1 << (64 - rotation));
                    
                    // Step 3: Reverse byte scrambling using unsafe pointer magic
                    byte pattern = (byte)(identifierHash % 8);
                    if (pattern == 0) return step2; // no scrambling
                    
                    byte* ptr = (byte*)&step2;
                    ulong result;
                    byte* resultPtr = (byte*)&result;
                    
                    switch (pattern)
                    {
                        case 1: // reverse: 3,1,7,0,4,6,2,5 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[3]; resultPtr[1] = ptr[1]; resultPtr[2] = ptr[6]; resultPtr[3] = ptr[0];
                            resultPtr[4] = ptr[4]; resultPtr[5] = ptr[7]; resultPtr[6] = ptr[5]; resultPtr[7] = ptr[2];
                            break;
                        case 2: // reverse: 5,2,0,6,3,7,1,4 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[2]; resultPtr[1] = ptr[6]; resultPtr[2] = ptr[1]; resultPtr[3] = ptr[4];
                            resultPtr[4] = ptr[7]; resultPtr[5] = ptr[0]; resultPtr[6] = ptr[3]; resultPtr[7] = ptr[5];
                            break;
                        case 3: // reverse: 6,3,1,5,7,0,4,2 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[5]; resultPtr[1] = ptr[2]; resultPtr[2] = ptr[7]; resultPtr[3] = ptr[1];
                            resultPtr[4] = ptr[6]; resultPtr[5] = ptr[3]; resultPtr[6] = ptr[0]; resultPtr[7] = ptr[4];
                            break;
                        case 4: // reverse: 2,6,4,1,0,5,7,3 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[4]; resultPtr[1] = ptr[3]; resultPtr[2] = ptr[0]; resultPtr[3] = ptr[7];
                            resultPtr[4] = ptr[2]; resultPtr[5] = ptr[5]; resultPtr[6] = ptr[1]; resultPtr[7] = ptr[6];
                            break;
                        case 5: // reverse: 1,7,5,3,6,2,0,4 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[6]; resultPtr[1] = ptr[0]; resultPtr[2] = ptr[5]; resultPtr[3] = ptr[3];
                            resultPtr[4] = ptr[7]; resultPtr[5] = ptr[2]; resultPtr[6] = ptr[4]; resultPtr[7] = ptr[1];
                            break;
                        case 6: // reverse: 4,0,6,2,1,3,5,7 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[1]; resultPtr[1] = ptr[4]; resultPtr[2] = ptr[6]; resultPtr[3] = ptr[5];
                            resultPtr[4] = ptr[0]; resultPtr[5] = ptr[2]; resultPtr[6] = ptr[7]; resultPtr[7] = ptr[3];
                            break;
                        case 7: // reverse: 7,5,2,6,1,4,3,0 -> 0,1,2,3,4,5,6,7
                            resultPtr[0] = ptr[7]; resultPtr[1] = ptr[5]; resultPtr[2] = ptr[2]; resultPtr[3] = ptr[6];
                            resultPtr[4] = ptr[1]; resultPtr[5] = ptr[4]; resultPtr[6] = ptr[3]; resultPtr[7] = ptr[0];
                            break;
                        default:
                            return step2;
                    }
                    return result;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private static unsafe uint ReverseComplexObfuscation32(uint obfuscated, long key1, long key2, string identifier)
                {
                    uint identifierHash = (uint)identifier.GetHashCode();
                    uint keyMix = (uint)((key1 ^ key2) ^ identifierHash);
                    
                    uint step1 = obfuscated ^ keyMix ^ 0x12345678U;
                    int rotation = (int)(identifierHash % 15) + 1; // 1-15
                    uint step2 = (step1 >> rotation) | (step1 << (32 - rotation));
                    
                    byte pattern = (byte)(identifierHash % 4);
                    if (pattern == 0) return step2;
                    
                    byte* ptr = (byte*)&step2;
                    uint result;
                    byte* resultPtr = (byte*)&result;
                    
                    switch (pattern)
                    {
                        case 1: // reverse: 3,1,0,2 -> 0,1,2,3
                            resultPtr[0] = ptr[2]; resultPtr[1] = ptr[1]; resultPtr[2] = ptr[3]; resultPtr[3] = ptr[0];
                            break;
                        case 2: // reverse: 2,0,3,1 -> 0,1,2,3
                            resultPtr[0] = ptr[1]; resultPtr[1] = ptr[3]; resultPtr[2] = ptr[0]; resultPtr[3] = ptr[2];
                            break;
                        case 3: // reverse: 1,2,3,0 -> 0,1,2,3
                            resultPtr[0] = ptr[3]; resultPtr[1] = ptr[0]; resultPtr[2] = ptr[1]; resultPtr[3] = ptr[2];
                            break;
                        default:
                            return step2;
                    }
                    return result;
                }
            }
            """;

        // Write the generated file
        string outputFile = Path.Combine(outputDir, "SecureConstants.generated.cs");
        File.WriteAllText(outputFile, content);
        
        Console.WriteLine($"Generated: {outputFile}");
    }


    static unsafe ulong ApplyComplexObfuscation(ulong value, long key1, long key2, string identifier)
    {
        uint identifierHash = (uint)identifier.GetHashCode();
        ulong keyMix = (ulong)(key1 ^ key2 ^ identifierHash);

        // Step 1: Byte scrambling based on identifier hash using unsafe pointers
        byte pattern = (byte)(identifierHash % 8);
        ulong scrambled;
        
        if (pattern == 0)
        {
            scrambled = value; // no scrambling
        }
        else
        {
            byte* srcPtr = (byte*)&value;
            byte* destPtr = (byte*)&scrambled;
            
            switch (pattern)
            {
                case 1: // scramble: 0,1,2,3,4,5,6,7 -> 3,1,7,0,4,6,2,5
                    destPtr[0] = srcPtr[3]; destPtr[1] = srcPtr[1]; destPtr[2] = srcPtr[7]; destPtr[3] = srcPtr[0];
                    destPtr[4] = srcPtr[4]; destPtr[5] = srcPtr[6]; destPtr[6] = srcPtr[2]; destPtr[7] = srcPtr[5];
                    break;
                case 2:
                    destPtr[0] = srcPtr[5]; destPtr[1] = srcPtr[2]; destPtr[2] = srcPtr[0]; destPtr[3] = srcPtr[6];
                    destPtr[4] = srcPtr[3]; destPtr[5] = srcPtr[7]; destPtr[6] = srcPtr[1]; destPtr[7] = srcPtr[4];
                    break;
                case 3:
                    destPtr[0] = srcPtr[6]; destPtr[1] = srcPtr[3]; destPtr[2] = srcPtr[1]; destPtr[3] = srcPtr[5];
                    destPtr[4] = srcPtr[7]; destPtr[5] = srcPtr[0]; destPtr[6] = srcPtr[4]; destPtr[7] = srcPtr[2];
                    break;
                case 4:
                    destPtr[0] = srcPtr[2]; destPtr[1] = srcPtr[6]; destPtr[2] = srcPtr[4]; destPtr[3] = srcPtr[1];
                    destPtr[4] = srcPtr[0]; destPtr[5] = srcPtr[5]; destPtr[6] = srcPtr[7]; destPtr[7] = srcPtr[3];
                    break;
                case 5:
                    destPtr[0] = srcPtr[1]; destPtr[1] = srcPtr[7]; destPtr[2] = srcPtr[5]; destPtr[3] = srcPtr[3];
                    destPtr[4] = srcPtr[6]; destPtr[5] = srcPtr[2]; destPtr[6] = srcPtr[0]; destPtr[7] = srcPtr[4];
                    break;
                case 6:
                    destPtr[0] = srcPtr[4]; destPtr[1] = srcPtr[0]; destPtr[2] = srcPtr[6]; destPtr[3] = srcPtr[2];
                    destPtr[4] = srcPtr[1]; destPtr[5] = srcPtr[3]; destPtr[6] = srcPtr[5]; destPtr[7] = srcPtr[7];
                    break;
                case 7:
                    destPtr[0] = srcPtr[7]; destPtr[1] = srcPtr[4]; destPtr[2] = srcPtr[2]; destPtr[3] = srcPtr[6];
                    destPtr[4] = srcPtr[5]; destPtr[5] = srcPtr[1]; destPtr[6] = srcPtr[3]; destPtr[7] = srcPtr[0];
                    break;
                default:
                    scrambled = value;
                    break;
            }
        }

        // Step 2: Bit rotation based on identifier
        int rotation = (int)(identifierHash % 31) + 1; // 1-31 bit rotation
        ulong rotated = (scrambled << rotation) | (scrambled >> (64 - rotation));

        // Step 3: XOR with keys and magic constant
        return rotated ^ keyMix ^ 0xABCDEF0123456789UL;
    }

    static unsafe uint ApplyComplexObfuscation32(uint value, long key1, long key2, string identifier)
    {
        uint identifierHash = (uint)identifier.GetHashCode();
        uint keyMix = (uint)((key1 ^ key2) ^ identifierHash);

        // Byte scrambling for 32-bit values using unsafe pointers
        byte pattern = (byte)(identifierHash % 4);
        uint scrambled;
        
        if (pattern == 0)
        {
            scrambled = value;
        }
        else
        {
            byte* srcPtr = (byte*)&value;
            byte* destPtr = (byte*)&scrambled;
            
            switch (pattern)
            {
                case 1: // scramble: 0,1,2,3 -> 3,1,0,2
                    destPtr[0] = srcPtr[3]; destPtr[1] = srcPtr[1]; destPtr[2] = srcPtr[0]; destPtr[3] = srcPtr[2];
                    break;
                case 2: // scramble: 0,1,2,3 -> 2,0,3,1
                    destPtr[0] = srcPtr[2]; destPtr[1] = srcPtr[0]; destPtr[2] = srcPtr[3]; destPtr[3] = srcPtr[1];
                    break;
                case 3: // scramble: 0,1,2,3 -> 1,2,3,0
                    destPtr[0] = srcPtr[1]; destPtr[1] = srcPtr[2]; destPtr[2] = srcPtr[3]; destPtr[3] = srcPtr[0];
                    break;
                default:
                    scrambled = value;
                    break;
            }
        }

        // Bit rotation
        int rotation = (int)(identifierHash % 15) + 1; // 1-15 bit rotation
        uint rotated = (scrambled << rotation) | (scrambled >> (32 - rotation));

        return rotated ^ keyMix ^ 0x12345678U;
    }

    static void GenerateAsymmetricConstants(string outputDir, 
        Dictionary<string, double> doubleConstants,
        Dictionary<string, int> intConstants, 
        Dictionary<string, decimal> decimalConstants)
    {
        Console.WriteLine("üîê Generating Level 4: Asymmetric encryption constants...");

        // Generate RSA key pair (private key only exists during compilation!)
        using var rsa = RSA.Create(2048);
        var publicKey = rsa.ExportRSAPublicKey();
        var privateKey = rsa.ExportRSAPrivateKey(); // This will be discarded after compilation!

        // Encrypt all constants
        var encryptedConstants = new Dictionary<string, byte[]>();
        
        foreach (var kvp in doubleConstants)
        {
            byte[] valueBytes = BitConverter.GetBytes(kvp.Value);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }
        
        foreach (var kvp in intConstants)
        {
            byte[] valueBytes = BitConverter.GetBytes(kvp.Value);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }
        
        foreach (var kvp in decimalConstants)
        {
            int[] decimalBits = decimal.GetBits(kvp.Value);
            byte[] valueBytes = new byte[16];
            Buffer.BlockCopy(decimalBits, 0, valueBytes, 0, 16);
            encryptedConstants[kvp.Key] = rsa.Encrypt(valueBytes, RSAEncryptionPadding.Pkcs1);
        }

        // Helper method to format byte arrays as hex
        static string FormatByteArray(byte[] bytes)
        {
            var result = new StringBuilder();
            for (int i = 0; i < bytes.Length; i++)
            {
                result.Append($"0x{bytes[i]:X2}");
                
                if (i < bytes.Length - 1)
                {
                    result.Append(", ");
                    if ((i + 1) % 16 == 0)
                    {
                        result.Append("\n            ");
                    }
                }
            }
            return result.ToString();
        }

        string content = $$"""
            // Level 4: Asymmetric Encryption Constants
            // Private key used at compile-time ONLY - not stored in binary!
            // This file is auto-generated by ConstantObfuscator at compile time
            // DO NOT EDIT MANUALLY - Changes will be overwritten

            using System.Runtime.CompilerServices;
            using System.Runtime.InteropServices;
            using System.Security.Cryptography;

            namespace HardToModifyRuntimeConstants;

            public static class CryptoConstants
            {
                private readonly struct EncryptedContainer()
                {
            {{string.Join("\n", encryptedConstants.Select(kvp => $$"""
                        public static readonly byte[] {{kvp.Key}} = new byte[]
                        {
                            {{FormatByteArray(kvp.Value)}}
                        };
            """))}}
                }

                // Only public key stored - private key existed only during compilation!
                private static readonly byte[] _publicKeyBytes = new byte[]
                {
                    {{FormatByteArray(publicKey)}}
                };

                private static readonly long _storage;
                private static readonly RSA? _rsa;
                private const long _pepper = unchecked((long)0xC437910C05744775);

                static CryptoConstants()
                {
                    EncryptedContainer container = new();
                    var pointer = GCHandle.Alloc(container, GCHandleType.Pinned).AddrOfPinnedObject().ToInt64();
                    _storage = pointer ^ _pepper;
                    
                    // Create RSA instance with public key only
                    try
                    {
                        _rsa = RSA.Create();
                        _rsa.ImportRSAPublicKey(_publicKeyBytes, out _);
                    }
                    catch
                    {
                        _rsa = null; // Graceful degradation
                    }
                }

            {{string.Join("\n\n", doubleConstants.Keys.Select(key => $$"""
                    public static double {{key}}
                    {
                        get
                        {
                            // SECURITY: Cannot decrypt without private key!
                            // Private key was discarded after compilation
                            throw new CryptographicException("Constants encrypted with compile-time private key cannot be decrypted at runtime. This is intentional for maximum security.");
                        }
                    }
            """))}}

            {{string.Join("\n\n", intConstants.Keys.Select(key => $$"""
                    public static int {{key}}
                    {
                        get
                        {
                            throw new CryptographicException("Constants encrypted with compile-time private key cannot be decrypted at runtime. This is intentional for maximum security.");
                        }
                    }
            """))}}

            {{string.Join("\n\n", decimalConstants.Keys.Select(key => $$"""
                    public static decimal {{key}}
                    {
                        get
                        {
                            throw new CryptographicException("Constants encrypted with compile-time private key cannot be decrypted at runtime. This is intentional for maximum security.");
                        }
                    }
            """))}}

                /// <summary>
                /// Demonstrates that constants are truly immutable - even with full source code access,
                /// the values cannot be recovered without the compile-time private key.
                /// </summary>
                public static string GetSecurityInfo()
                {
                    return $"Level 4 Security: Constants encrypted with RSA-2048. " +
                           $"Private key existed only during compilation and was discarded. " +
                           $"Public key size: {_publicKeyBytes.Length} bytes. " +
                           $"Decryption impossible without private key.";
                }
            }
            """;

        // Write the generated file
        string outputFile = Path.Combine(outputDir, "CryptoConstants.generated.cs");
        File.WriteAllText(outputFile, content);
        
        Console.WriteLine($"Generated: {outputFile}");
        Console.WriteLine($"üî• PRIVATE KEY DISCARDED - exists only during compilation!");
        Console.WriteLine($"üìñ Public key stored ({publicKey.Length} bytes) - cannot decrypt data");

        // Explicitly clear sensitive data
        Array.Clear(privateKey, 0, privateKey.Length);
        Console.WriteLine("üóëÔ∏è  Private key securely cleared from memory");
    }
}
